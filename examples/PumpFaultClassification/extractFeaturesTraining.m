function [featureTable,outputTable] = extractFeaturesTraining(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  flow_ps/Data
%  pressure_ps/Data
%
% This function computes features:
%  flow_stats/Data_ClearanceFactor
%  flow_stats/Data_CrestFactor
%  flow_stats/Data_ImpulseFactor
%  flow_stats/Data_Mean
%  flow_stats/Data_RMS
%  flow_stats/Data_THD
%  pressure_stats/Data_CrestFactor
%  pressure_stats/Data_ImpulseFactor
%  pressure_stats/Data_Mean
%  pressure_stats/Data_RMS
%  pressure_stats/Data_THD
%  flow_ps_spec/Data_PeakAmp1
%  flow_ps_spec/Data_PeakAmp3
%  pressure_ps_spec/Data_PeakAmp1
%  pressure_ps_spec/Data_PeakAmp3
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 09-May-2023 13:21:27

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',["flow";"pressure"],'ConditionVariables',"faultCode");

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"flow_stats";"pressure_stats";"flow_ps";"pressure_ps";"flow_ps_spec";"pressure_ps_spec"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = ["flow","pressure"];

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    flow = readMemberData(member,"flow",["Time","Data"]);
    pressure = readMemberData(member,"pressure",["Time","Data"]);

    % Initialize a table to store results.
    memberResult = table;

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = flow.Data;
        Data_ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        Data_CrestFactor = peak2rms(inputSignal);
        Data_ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Data_Mean = mean(inputSignal,'omitnan');
        Data_RMS = rms(inputSignal,'omitnan');
        Data_THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [Data_ClearanceFactor,Data_CrestFactor,Data_ImpulseFactor,Data_Mean,Data_RMS,Data_THD];

        % Package computed features into a table.
        featureNames = {'Data_ClearanceFactor','Data_CrestFactor','Data_ImpulseFactor','Data_Mean','Data_RMS','Data_THD'};
        flow_stats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,6);
        featureNames = {'Data_ClearanceFactor','Data_CrestFactor','Data_ImpulseFactor','Data_Mean','Data_RMS','Data_THD'};
        flow_stats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_stats},'VariableNames',{'flow_stats'})]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = pressure.Data;
        Data_CrestFactor = peak2rms(inputSignal);
        Data_ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Data_Mean = mean(inputSignal,'omitnan');
        Data_RMS = rms(inputSignal,'omitnan');
        Data_THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [Data_CrestFactor,Data_ImpulseFactor,Data_Mean,Data_RMS,Data_THD];

        % Package computed features into a table.
        featureNames = {'Data_CrestFactor','Data_ImpulseFactor','Data_Mean','Data_RMS','Data_THD'};
        pressure_stats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,5);
        featureNames = {'Data_CrestFactor','Data_ImpulseFactor','Data_Mean','Data_RMS','Data_THD'};
        pressure_stats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_stats},'VariableNames',{'pressure_stats'})]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(flow.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x_raw = flow.Data;
        if irregular
            x = resample(x_raw,tNumeric,Fs,'linear');
        else
            x = x_raw;
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','Data');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,20,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', {'Time', 'Data'});
        ps.Properties.VariableUnits = {'Hz', ''};
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        flow_ps = ps;
    catch
        flow_ps = table(NaN, NaN, 'VariableNames', {'Time', 'Data'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_ps},'VariableNames',{'flow_ps'})]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(pressure.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x_raw = pressure.Data;
        if irregular
            x = resample(x_raw,tNumeric,Fs,'linear');
        else
            x = x_raw;
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','Data');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,20,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', {'Time', 'Data'});
        ps.Properties.VariableUnits = {'Hz', ''};
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        pressure_ps = ps;
    catch
        pressure_ps = table(NaN, NaN, 'VariableNames', {'Time', 'Data'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_ps},'VariableNames',{'pressure_ps'})]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = flow_ps.Data;
        w = flow_ps.Time;
        w = factor*w;
        mask_1 = (w>=factor*1.59154943091895e-05) & (w<=factor*180.000010185916);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',3);
        peakAmp = [peakAmp(:); NaN(3-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(3-numel(peakFreq),1)];

        % Extract individual feature values.
        Data_PeakAmp1 = peakAmp(1);
        Data_PeakAmp3 = peakAmp(3);

        % Concatenate signal features.
        featureValues = [Data_PeakAmp1,Data_PeakAmp3];

        % Package computed features into a table.
        featureNames = {'Data_PeakAmp1','Data_PeakAmp3'};
        flow_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,2);
        featureNames = {'Data_PeakAmp1','Data_PeakAmp3'};
        flow_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_ps_spec},'VariableNames',{'flow_ps_spec'})]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = pressure_ps.Data;
        w = pressure_ps.Time;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*180.101859163579);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',3);
        peakAmp = [peakAmp(:); NaN(3-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(3-numel(peakFreq),1)];

        % Extract individual feature values.
        Data_PeakAmp1 = peakAmp(1);
        Data_PeakAmp3 = peakAmp(3);

        % Concatenate signal features.
        featureValues = [Data_PeakAmp1,Data_PeakAmp3];

        % Package computed features into a table.
        featureNames = {'Data_PeakAmp1','Data_PeakAmp3'};
        pressure_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,2);
        featureNames = {'Data_PeakAmp1','Data_PeakAmp3'};
        pressure_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_ps_spec},'VariableNames',{'pressure_ps_spec'})]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeToLastMemberRead(outputEnsemble,memberResult)
end

% Gather all features into a table.
selectedFeatureNames = ["flow_stats/Data_ClearanceFactor","flow_stats/Data_CrestFactor","flow_stats/Data_ImpulseFactor","flow_stats/Data_Mean","flow_stats/Data_RMS","flow_stats/Data_THD","pressure_stats/Data_CrestFactor","pressure_stats/Data_ImpulseFactor","pressure_stats/Data_Mean","pressure_stats/Data_RMS","pressure_stats/Data_THD","flow_ps_spec/Data_PeakAmp1","flow_ps_spec/Data_PeakAmp3","pressure_ps_spec/Data_PeakAmp1","pressure_ps_spec/Data_PeakAmp3"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
outputTable = readall(outputEnsemble);
end
